Ubuntu 14.04 

1)Installing Docker

apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
echo "deb https://apt.dockerproject.org/repo ubuntu-trusty main" > /etc/apt/sources.list.d/docker.list

apt-get update
apt-get purge lxc-docker*
apt-cache policy docker-engine
apt-get install docker-engine

2)Creating Docker Group and adding User(jithinr)
//groupadd <groupname>
groupadd docker
//sudo gpasswd -a <username> <groupname>
sudo gpasswd -a jithinr docker

//Permission to "docker" group
// chown root:<groupname> /var/run/docker.sock
chown root:docker /var/run/docker.sock
reboot

//Cross-checking the permission for the group
cat /etc/group | grep -i docker

3)Resolving network issue for ssh installation and installing open ssh-server on Ubuntu image

//Resolving n/w issue for ssh installation
vi /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
#nameserver 127.0.1.1
nameserver 172.27.172.10                       //Cybage Network
search cybage.com


vi /etc/default/docker

//Installing ssh-sserver on Ubuntu Image
sudo apt-get install openssh-server
sudo service ssh restart

4)docker basic commands
docker -v
docker version
docker info

5 a) To create an image 
docker build -t ubuntu:jjrc .
docker run -it ubuntu /bin/bash
5 b)To start a container
//ubuntu  :- image name
// -it    :- make it interactive and assign TTY
/bin/bash :- inside the container we are running bash process

docker run -it ubuntu /bin/bash

6)//Using docker unit socket
sudo netstat -tlp      //netstat :- network status  ,  tlp :- tcp listening program
//Using network 
docker -H <ip_address>:port -d &                      // -d :- daemon mode  ,  & - for giving cmd back 
docker -H 172.27.59.190:2375 -d &

//For checking docker connection
  ps -aux | grep docker

7)To check container status 
//Active Container 
docker ps
docker container ls 
//Conatiners that have ever run on the machine
docker ps -a  
docker container ls -a
//Location of the container on local machine
/var/lib/docker/<storage_driver>
/var/lib/docker/aufs/diff

8)For seeing docker images
docker images

9)Docker container is still running and we are on normal host machine(Detaching our container)
Control + P+Q
docker ps  // For checking current running container

10)Stopping container from outside of the container
docker stop {<container _id>/<container_name>}

11)//Last container that have run
docker ps -l

//For starting and opening container
docker start <container_id>  // we won't go inside container
docker attach <container_id> // we will go inside container

//Removing an inactive container
docker rm {<container_id>/<container_name>}       
//Removing a running/active container 
docker rm -f {<container_id/<contanier_name>}


//Creating alias
alias <alias_name>="<command>"
alias dps="docker ps"       //Example


12)Exact command inside a container for executing bash terminal

a)nsenter(entering name space)
#Need Pid(Process Id) of the container
docker inspect <container_id> | grep Pid
nsenter -m -u -n -p -i -t <container's_Pid> /bin/bash

b)docker-enter <container_id>

c)docker exec -it <container_id> /bin/bash

13)Pushing images to repository
Before pushing the images,we need to tag it first
a)docker images
b)docker tag <image_id> <repo_name where it is to be pushed:version>
c)docker push <repo_name where it is to be pushed:version> 

docker pull <imagename>			//For pulling the image from dockerhub

 
14)Removing Containers/Images
//Removing Containers
docker ps -a
docker rm <container_id>

//Removing Images
docker images
docker rmi <image_id>

15)Difference b/w CMD and RUN
CMD                                 		RUN
a)run-time                          		a)build-time
b)run-commands in container in launch time	b)add layers to images
c)equivalent to 							c)used to install apps
docker run <args> <command>
docker run <args> /bin/bash

docker container run -d -p 3306:3306 ubuntu:jithin

d)one per Dockerfile
CMD takes two forms/styles
(i)shell form
commands are expressed the same way as shell
commands
(ii)exec form
JSON array style(ie., ["command","arg1"])
Container does not need a shell
Avoid string munging by the shell
No shell features:-
No variable expansion,special characters

ENTRYPOINT

a)Can't be overridden at the runtime with the normal commands
docker run <command>
Any command at run-time is used as an argument to ENTRYPOINT

Ex :- docker build -t = "hw2" .
docker run -it hw2 /bin/bash
instead of considering /bin/bash as a command
it is interpreted as an argument to the ENTRYPOINT

If ENTRYPOINT is specified,CMD in Dockerfile also get interpreted as arguments 
CMD instructions in the docker gets overridden at runtime art options at the docker run command 

16) ENV command

ENV var = value

17)VOLUME

a)Decoupling of data from the container
docker run -it -v /test-vol --name=voltainer ubuntu14.04 /bin/bash
where
-v //volume,  /test-vol //foldername, voltainer  //container name

b)Second container can access the data of first container and share its contents

docker run -it --volumes-from=voltainer ubuntu14.04 /bin/bash
                              <1st container name>

c)Mounting a directory from docker host to container(host_mount)
	docker run -v /data:/data
                //(docker host):(container)
				
d)docker run -it --name voltest2 -v /opt/Demo:/mydata ubuntu:latest /bin/bash
	where /opt/Demo This is host name directory   and /mydata is container directory

	
We can't specify host refer directory to container refer directory using volumes which is keeping inside Dockerfile.
	
e)Deleting volumes
Delete the volume within the container
docker rm -v <container_name>
if we delete the container without deleting volume,volume will be still remain


18)

a)By default each container get one interface automatically attached to the docker0
b)By default resolv.conf of every container is same as resolv.conf of docker host
c)Exposing port at the runtime
 We need to launch the docker container with -p option when doing docker run

d)Port forwarding
docker run -p 5001:80 
5001 port on docker host;       80 is the port on the container

docker run -d -p 172.27.59.96:5003:8080 --name=web3 tomcat7

-P to expose all the ports
docker run -d -P --name=web4 tomcat7 
first available port is 32768 (last is 65000)

e)Container Linking
Pros:- More secure than exposing port

Cons:- Only container-container communication

docker run --name=src -t tomcat7
where src is the name of the container, tomcat7 is the name of the image

docker run --name=rcvr --link=src:ali-src -it for_demo /bin/bash
where rcvr is the name of the container, src is the name of the previous container, ali-src is the alias-name of the current container
for_demo is the name of the image from which rcvr container is getting created

19)docker commands

docker run -it --name=tomcat7container tomcat7
docker run -it --name=mysqlcontainer mysql /bin/bash
docker stats		//performance status of all containers
/var/lib/tomcat7/webapps

To delete all the containers
docker rm `docker ps -qa`

20)Docker Networking
a)By default,docker comes with the range 172.17.0.*
  When you launch a container,it launch with ip address from 172.17.0.2 or above.
b)docker network ls						//For checking the different docker network type which are available
b871137771d0        bridge              bridge              local
8e8cef88d401        host                host                local
9909e670a2f1        none                null                local

c)man docker-network-create
This is for creating docker network.
docker network create --subnet 10.1.0.0/24 --gateway 10.1.0.1 mybridge
Here --subnet is the range of the network and gateway is the starting point of that network

d)docker network rm mybridge(bridge name)					//This is for removing/deleting network
Static ip can be assigned to a container if we have used user build network.
docker run -it --name nettest2 --net bridge04 --ip 10.1.4.100 centos:latest /bin/bash
Here ip is 10.1.4.100 which is static
bridge4 is the network which we have created

e)Each container connected to private virtual network called bridge.All containers on virtual network can talk each other without -p.

f)--network host	//It gains performance by skipping virtual networks but sacrifices security of container model.
  --network null	//Removes eth0 and only leaves you localhost interface in container 
g)docker network connect <container_id> 	//Dynamically creates a NIC in a container on an existing virtual network.
  docker network disconnect <container_id>  //Dynamically removes a NIC from a container  on a specific virtual network.
h)Docker daemon has a built-in DNS server that containers use by default.
Docker defaults the hostname to container's name,but can also set alias. 

21)Saving and loading docker images  
a)Saving Docker images
docker save ubuntu:march >> ubuntu.latest.tar
docker save -o ubuntu.latest1.tar ubuntu:latest
docker save --output ubuntu.latest2.tar ubuntu:latest 

b)Loading Docker images
docker load <ubuntu.latest.tar
docker load --input ubuntu.latest.tar.

22)Docker Compose
a)
Docker compose consists of two parts.
(i)YAML file - which contain containers,networks and volumes.
(ii)A CLI tool docker compose used for local dev/test automation with those YAML files
b)Docker Compose commands
docker-compose up 				//For running docker compose file
docker-compose ps 				//To see what is currently running
docker-compose stop				//for stopping the container
docker-compose down --volumes 	//-volumes to also remove the data volume used by the Redis container
c)Features of Compose that make it effective are:
Multiple isolated environments on a single host
Preserve volume data when containers are created
Only recreate containers that have changed
Variables and moving a composition between environments